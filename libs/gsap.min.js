
// GSAP library would be loaded here
// For this demo, we'll use a simplified version
// In production, load from: https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js

// Simplified GSAP implementation for demo
window.gsap = {
  to: function(target, vars) {
    const element = typeof target === 'string' ? document.querySelector(target) : target;
    if (!element) return;
    
    const duration = (vars.duration || 1) * 1000;
    const startTime = Date.now();
    const startStyles = {};
    
    // Store initial values
    Object.keys(vars).forEach(prop => {
      if (prop !== 'duration' && prop !== 'ease' && prop !== 'onComplete') {
        startStyles[prop] = this.getStyleValue(element, prop);
      }
    });
    
    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      Object.keys(vars).forEach(prop => {
        if (prop !== 'duration' && prop !== 'ease' && prop !== 'onComplete') {
          const startValue = startStyles[prop];
          const endValue = vars[prop];
          const currentValue = startValue + (endValue - startValue) * progress;
          this.setStyleValue(element, prop, currentValue);
        }
      });
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else if (vars.onComplete) {
        vars.onComplete();
      }
    };
    
    requestAnimationFrame(animate);
    
    return {
      kill: () => {}
    };
  },
  
  fromTo: function(target, fromVars, toVars) {
    const element = typeof target === 'string' ? document.querySelector(target) : target;
    if (!element) return;
    
    // Set initial values
    Object.keys(fromVars).forEach(prop => {
      this.setStyleValue(element, prop, fromVars[prop]);
    });
    
    // Animate to target values
    return this.to(element, toVars);
  },
  
  timeline: function(vars = {}) {
    return {
      to: (target, options) => gsap.to(target, options),
      fromTo: (target, from, to) => gsap.fromTo(target, from, to)
    };
  },
  
  getStyleValue: function(element, prop) {
    switch (prop) {
      case 'x': return parseInt(element.style.left) || 0;
      case 'y': return parseInt(element.style.top) || 0;
      case 'scale': return parseFloat(element.style.transform.match(/scale\(([^)]+)\)/)?.[1]) || 1;
      case 'rotation': return parseFloat(element.style.transform.match(/rotate\(([^)]+)deg\)/)?.[1]) || 0;
      case 'opacity': return parseFloat(element.style.opacity) || 1;
      default: return 0;
    }
  },
  
  setStyleValue: function(element, prop, value) {
    switch (prop) {
      case 'x':
        element.style.left = value + 'px';
        break;
      case 'y':
        element.style.top = value + 'px';
        break;
      case 'scale':
        element.style.transform = (element.style.transform || '').replace(/scale\([^)]*\)/, '') + ` scale(${value})`;
        break;
      case 'rotation':
        element.style.transform = (element.style.transform || '').replace(/rotate\([^)]*\)/, '') + ` rotate(${value}deg)`;
        break;
      case 'opacity':
        element.style.opacity = value;
        break;
    }
  }
};

console.log('GSAP: Loaded (simplified version for demo)');
